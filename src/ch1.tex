\chapter{操作系统的组织结构}

操作系统的一个核心需求是同时支持多个活动。
例如，使用第0章中介绍的系统调用，一个进程可以通过\texttt{fork}创建新的进程。
操作系统必须在进程之间\emph{分时共享(time-share)}计算机的资源。
例如，即使有比硬件处理器数量更多的进程，操作系统也要保证所有的进程都可以继续推进。
操作系统还必须实现进程之间的\emph{隔离(isolation)}。
即，如果一个进程有bug并且失败了，它不应该影响到那些不依赖这个进程的进程。
然而，完全的隔离太过苛刻，因为进程之间可能需要交互，管道就是一个例子。
因此一个操作系统必须满足这三个要求：多路复用，隔离性，交互性。

这一章提供了操作系统是如何组织以满足三个需求的概述。
事实证明有很多方法可以做到这一点，但本文专注于基于\emph{宏内核(monolithic kernel)}的主流设计，很多Unix操作系统都采用了宏内核的方式。
本章通过追踪当xv6开始运行时第一个进程的创建过程来介绍xv6的设计。
同时，本章还简单展示了xv6提供的所有主要抽象的实现、它们如何交互，以及如何满足多路复用、隔离性和交互性。
xv6尽量避免对第一个进程进行特殊处理，而是重用xv6提供的用于进行标准操作的代码。
随后的章节将会详细介绍每一个抽象。

xv6运行在PC平台上的Intel 80386或更新的（“x86”）处理器上，它的大多数底层功能（例如进程的实现）是x86特定的。
本书假设读者已经有过某些架构的机器级编程的经验，并在遇到x86特定的实现时进行介绍。
附录A简单介绍了PC平台。

\section*{抽象物理资源}
说到操作系统，很多人的第一个问题可能是为什么需要它？
事实上，我们可以把\autoref{t0-1}中的系统调用实现为库，然后让应用链接它。
在这种模式下，每一个应用甚至可以有根据自己需求量身定做的库。
应用可以直接和硬件资源交互，并且采用对应用来说最合适的方式来使用资源（例如，用来实现很高或者可预测的性能）。
一些嵌入式设备或实时系统的操作系统就是以这种方式组织的。

这种库方式的缺点是，如果有不止一个应用在运行，那么这些应用必须行为良好。
例如，每一个应用必须周期性地放弃处理器，这样其他应用才能运行。
如果所有的应用都互相信任并且没有bug，那么这种\emph{协作(co-operative)}分时方案可能也OK。
然而，更常见的情况是应用并不信任彼此，并且还可能有bug，因此我们通常需要比协作方案更强的隔离性。

为了实现强隔离性，禁止应用直接访问敏感的硬件资源，而是将资源抽象为服务会很有帮助。
例如，应用和文件系统交互时通过\texttt{open, read, write, close}系统调用，而不是读写原始的磁盘扇区。
这为应用程序提供了路径名的便利，并且允许操作系统（作为接口的实现者）来管理磁盘。

与此类似，Unix在进程之间透明地切换处理器，必要时保存并恢复寄存器状态，因此应用不需要考虑时间共享。
这种透明性允许操作系统即使遇到一些陷入无限循环的应用时也可以共享处理器。

作为另一个例子，Unix进程使用\texttt{exec}来构建自己的内存镜像，而不是直接和物理内存交互。
这允许操作系统来决定把进程加载到内存的哪一部分；如果内存很紧张，操作系统甚至可以把进程的部分数据存储在磁盘上。
\texttt{exec}也为应用提供了把可执行程序镜像存储在文件系统中的便利。

Unix进程之间的很多交互方式都是通过文件描述符。
文件描述符不仅仅通过抽象消除了一些细节（例如，管道或文件中的数据存储在哪里），它们还定义了一种简化交互的方式。
例如，如果一个管道中的某个应用失败了，那么内核会为管道中的下一个进程生成end-of-file。

如你所见，\autoref{t0-2}中的系统调用接口被精心设计，以在给程序员提供便利的同时提供强隔离性。
Unix接口不是唯一抽象资源的方式，但它被证明是一种非常优秀的方式。

