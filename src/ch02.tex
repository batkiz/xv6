\chapter{操作系统的组织结构}\label{ch02}

操作系统的一个核心需求是同时支持多个活动。
例如，使用\autoref{ch01}中介绍的系统调用，一个进程可以通过\texttt{fork}创建新的进程。
操作系统必须在进程之间\emph{分时共享(time-share)}计算机的资源。
例如，即使有比硬件处理器数量更多的进程，操作系统也要保证所有的进程都能获得执行的机会。
操作系统还必须实现进程之间的\emph{隔离(isolation)}。
即，如果一个进程有bug并且失败了，它不应该影响到那些不依赖这个进程的进程。
然而，完全的隔离太过苛刻，因为进程之间可能需要交互，管道就是一个例子。
因此一个操作系统必须满足这三个要求：多路复用，隔离性，交互性。

这一章提供了操作系统是如何组织以满足三个需求的概述。
事实证明有很多方法可以做到这一点，但本文专注于基于\emph{宏内核(monolithic kernel)}的主流设计，很多Unix操作系统都采用了宏内核的方式。
本章还提供了xv6进程的概述和当xv6启动时第一个进程的创建，进程是xv6中的隔离单元。

xv6运行在一台\emph{多核(multi-core)}\footnote{本书中的“多核”指的是共享内存但可以并行执行的多个CPU，每一个都有自己的寄存器。本书有时也会用术语\emph{多处理器(multiprocessor)}作为多核的同义词，尽管多处理器也可以指代有多个处理器芯片的计算机。}  RISC-V微处理器上，很多底层设施（例如，进程的实现）是RISC-V特定的。
RISC-V是64位的CPU，xv6也是用“LP64”C写成的，“LP64”的意思C语言中的是long（L）和pointer（P）都是64位的，而int是32位的。
这本书假设读者已经了解了某些架构的机器级编程，并在遇到时介绍RISC-V规范的思路。
RISC-V的一份很有用的参考文献是“The RISC-V Reader: An Open Architecture Atlas”[15]。
用户级的ISA[2]和特权架构[3]都是官方的规范。

一台完整计算机中的CPU被支持硬件环绕，它们中的大多数组成了I/O接口。
xv6的支持硬件通过qemu的“-machine virt”选项进行模拟。
其中包括RAM，一个包含启动代码的ROM，一个连接到用户键盘/屏幕的串口，一个用于存储的磁盘。

\section{抽象物理资源}
说到操作系统，很多人的第一个问题可能是为什么需要它？
事实上，我们可以把\autoref{t1-1}中的系统调用实现为库，然后让应用链接它。
在这种模式下，每一个应用甚至可以有根据自己需求量身定做的库。
应用可以直接和硬件资源交互，并且采用对应用来说最合适的方式来使用资源（例如，用来实现很高或者可预测的性能）。
一些嵌入式设备或实时系统的操作系统就是以这种方式组织的。

这种库方式的缺点是，如果有不止一个应用在运行，那么这些应用必须行为良好。
例如，每一个应用必须周期性地放弃处理器，这样其他应用才能运行。
如果所有的应用都互相信任并且没有bug，那么这种\emph{协作(co-operative)}分时方案可能也OK。
然而，更常见的情况是应用并不信任彼此，并且还可能有bug，因此我们通常需要比协作方案更强的隔离性。

为了实现强隔离性，禁止应用直接访问敏感的硬件资源，而是将资源抽象为服务会很有帮助。
例如，Unix应用和文件系统交互时通过\texttt{open}、\texttt{read}、\texttt{write}、\texttt{close}系统调用，而不是读写原始的磁盘扇区。
这为应用程序提供了路径名的便利，并且允许操作系统（作为接口的实现者）来管理磁盘。
即使并不关心隔离性，想要进行交互（或者只是希望不会阻挡彼此）的进程也会发现文件系统是比直接使用磁盘更方便的抽象。

与此类似，Unix在进程之间透明地切换处理器，必要时保存并恢复寄存器状态，因此应用不需要考虑时间共享。
这种透明性允许操作系统即使遇到一些陷入无限循环的应用时也可以共享处理器。

作为另一个例子，Unix进程使用\texttt{exec}来构建自己的内存镜像，而不是直接和物理内存交互。
这允许操作系统来决定把进程加载到内存的哪一部分；如果内存很紧张，操作系统甚至可以把进程的部分数据存储在磁盘上。
\texttt{exec}也为应用提供了把可执行程序镜像存储在文件系统中的便利。

Unix进程之间的很多交互方式都是通过文件描述符。
文件描述符不仅仅通过抽象消除了一些细节（例如，管道或文件中的数据存储在哪里），它们还定义了一种简化交互的方式。
例如，如果一个管道中的某个应用失败了，那么内核会为管道中的下一个进程生成end-of-file。

如你所见，\autoref{t1-1}中的系统调用接口被精心设计，以在给程序员提供便利的同时提供强隔离性。
Unix接口不是唯一抽象资源的方式，但它被证明是一种非常优秀的方式。

\section{用户模式、内核模式、系统调用}
强隔离性需要应用和操作系统之间有明显的界限。
如果一个应用出错了，我们不想让操作系统或者其他应用也失败。
反而，操作系统应该能清理失败的应用，然后继续运行其他的应用。
为了达到强隔离性，操作系统必须保证应用不能修改（或者甚至不能读取）操作系统的数据结构和指令，也不能访问其他进程的内存。

CPU为强隔离性提供了硬件支持。
例如，RISC-V有三种执行指令的模式：\emph{机器模式(machine mode)}、\emph{管理模式(supervisor mode)}和\emph{用户模式(user mode)}。
在机器模式下执行的指令拥有全部的特权；CPU启动时就是在机器模式下。
机器模式通常用来对计算机进行设置。
xv6会在机器模式下执行少量代码然后切换到管理模式。

在管理模式下，CPU可以执行\emph{特权指令(privileged instruction)}：例如，启用和禁用终端，读写保存页表地址的寄存器，等等。
如果一个用户模式下的应用尝试执行特权指令，那么CPU并不会执行这些指令，而是会切换到管理模式，并且管理模式的代码可以终止这个应用，因为它做了一些它不该做的。
\autoref{ch01}中的\autoref{f1-1}展示了这个架构。
应用只能执行用户模式的指令（例如数字加法等），被称为在\emph{用户空间(user space)}中执行；而管理模式下的软件还可以执行特权指令，被称为在\emph{内核空间(kernel space)}中执行。
在内核空间中（或管理模式下）执行的软件被称为\emph{内核(kernel)}。

如果一个应用想要调用一个内核函数（例如，xv6中的\texttt{read}系统调用），那么它必须过渡到内核来做这件事，因为应用自身\emph{不能}直接调用内核函数。
CPU提供了特殊的指令用于将处理器从用户模式转换到管理模式，并且在内核指定的入口点进入内核。（RISC-V提供了\texttt{ecall}指令来实现这一点。）
一旦处理器切换到管理模式，内核可以验证系统调用的参数（例如，检查传给系统调用的地址是否是应用内存的一部分），决定应用是否被允许执行请求的操作（例如，检查应用是否被允许写入指定的文件），然后拒绝它或者执行它。
过渡到管理模式时的入口点是由内核控制的，这一点非常重要：如果应用可以决定内核的入口点，一个恶意的应用就可以在一个跳过参数验证的地方进入内核。

\section{内核架构}
一个关键的设计问题就是操作系统的哪些部分应该在管理模式运行。
一种可能是整个操作系统都在内核里运行，这样所有系统调用的实现就都在管理模式运行。
这种架构被称为\emph{宏内核(monolithic kernel)}。

在这种架构下整个操作系统都在有完全的硬件特权的情况下运行。
这种架构非常方便，因为操作系统的设计者们不需要决定操作系统的哪些部分不需要完全的硬件特权。不仅如此，它还有利于操作系统不同模块之间的协作。例如，操作系统可以拥有一个由文件系统和虚拟内存系统所共享的缓冲区缓存。

宏内核架构的缺点是操作系统的不同部分之间的接口通常很复杂（正如我们将在之后看到的），而且也因此很容易导致操作系统开发者犯错。
在宏内核中错误是致命的，因为一个管理模式下的错误通常导致整个内核的终止。
如果内核终止了，计算机就会停止工作，因此所有的应用也会终止。
计算机必须重启才能再次工作。

为了减少内核中错误的风险，OS的设计者们可以最小化在内核态中运行的操作系统代码的数量，并在用户态下执行操作系统的大部分内容。
这种内核架构被称为\emph{微内核(micro kernel)}。

\autoref{f2-1}展示了微内核的设计。
图中文件系统作为用户级进程运行。
以进程的形式运行的操作系统服务被称为server。
为了允许应用和文件server交互，内核会提供一种进程间的通信机制来允许一个用户态的进程向另一个进程发送消息。
例如，如果一个应用例如shell想要读写一个文件，它会向文件server发送一条消息然后等待响应。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../imgs/f2-1.png}
    \caption{有一个文件server的微内核}
    \label{f2-1}
\end{figure}

在微内核中，内核的接口由一些底层的函数，例如启动应用、发送消息、访问设备硬件等等，组合而成。
这种架构会让内核变得相对简单一点，因为操作系统的大部分都在用户态的server中运行。

Xv6和大多数Unix操作系统一样被实现为宏内核。因此，在xv6中，内核接口也对应着操作系统接口，内核实现了全部的操作系统。因为xv6并不提供很多服务，因此它的内核比一些微内核还要小。

在真实世界中，宏内核和微内核都很流行。
很多Unix内核是宏内核。
例如，尽管一些操作系统函数以用户态server运行（例如，窗口系统），但Linux是宏内核。
Linux能为操作系统密集型应用程序提供很好的性能，一部分原因就是内核的各个子系统可以紧密地结合。

像Minix、L4、QNX这样的操作系统被组织为微内核，它们在嵌入式场景中得到了广泛的部署。
L4的一个变体seL4，足够小以至于已经被验证了内存安全性和其他安全属性[8]。

操作系统开发者对哪种架构更好有很大争议，但并没有确凿的证据。
另外，这还取决于“更好”的定义：更快的性能？更小的代码体积？内核的可靠性？整个操作系统（包括用户层的服务）的可靠性？等等。

还有一些实际考虑因素可能比选择哪种架构的问题更重要。
一些操作系统虽然是微内核但为了性能把一些用户层的服务运行在内核空间中。
一些操作系统之所以是宏内核，是因为它们最初从宏内核开始，并且很难迁移到纯粹的微内核架构，也可能因为新的功能可能比重写现有系统到微内核架构更重要。

从本书的角度来看，微内核和宏内核操作系统共享了很多关键的思路。
它们实现了系统调用，它们使用了页面，它们处理了终端，它们支持进程，它们使用锁进行并发控制，它们实现了文件系统，等等。
本书聚焦于这些核心的思路。

xv6和大多数Unix操作系统一样被实现为宏内核。
因此，xv6内核接口对应操作系统的接口，内核实现了整个操作系统。
因为xv6并不提供很多服务，所以它的内核比一些微内核还小，但从概念上讲xv6是宏内核。

\section{代码：xv6架构}
xv6的内核源码在\texttt{kernel/}子目录下。
源代码按照模块化的粗略概念分为若干文件，\autoref{t2-1}列出了这些文件。
模块间的接口被定义在\texttt{defs.h}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/defs.h}{(kernel/defs.h)}里。

\begin{table}[htbp]
    \centering
    \begin{tabular}{l|l}
        \textbf{文件}   & \textbf{介绍} \\
        \hline
        bio.c       & 文件系统的磁盘块缓存。    \\
        console.c   & 连接到用户键盘和屏幕。    \\
        entry.S     & 最早启动的指令。         \\
        exec.c      & exec()系统调用。        \\
        file.c       & 文件描述符支持。         \\
        fs.c        & 文件系统。              \\
        kalloc.c    & 物理页分配器。           \\
        kernelvec.S & 处理内核的自陷和计时器中断。  \\
        log.c       & 文件系统日志和崩溃恢复。   \\
        main.c      & 控制启动时其他模块的初始化。\\
        pipe.c      & 管道。                  \\
        plic.c      & RISC-V中断控制器。       \\
        printf.c    & 格式化终端的输出。        \\
        proc.c      & 进程和调度。             \\
        sleeplock.c & 让出CPU的锁。            \\
        spinlock.c  & 不让出CPU的锁。           \\
        start.c     & 机器模式下的启动代码。      \\
        string.c    & C字符串和字节数组库。       \\
        swtch.S     & 线程切换。                \\
        syscall.c   & 把系统调用分发到处理函数。   \\
        sysfile.c   & 文件相关的系统调用。         \\
        sysproc.c   & 进程相关的系统调用。        \\
        trampoline.S& 在用户和内核之间切换的汇编代码。\\
        trap.c      & 处理自陷和中断并返回的C代码。 \\
        uart.c      & 串口控制台设备驱动。         \\
        virtio\_disk.c  & 磁盘设备驱动。          \\
        vm.c        & 管理页表和地址空间。         \\
    \end{tabular}
    \caption{xv6内核源文件。}
    \label{t2-1}
\end{table}

\section{进程概览}
xv6中的隔离单元（和其他Unix操作系统一样）是\emph{进程(process)}。
进程的抽象可以阻止一个进程破坏或者窥探另一个进程的内存、CPU、文件描述符等内容。
它还可以防止一个进程破坏内核本身，因此一个进程不可能颠覆内核的隔离机制。
内核必须小心实现进程的抽象，因为一个有bug的或者恶意的应用可能会欺骗内核或硬件做一些坏事（例如规避强制隔离）。
内核用来实现进程的机制包括用户/管理态标志、地址空间和线程的时间分片。

为了实现强制隔离，进程抽象为每个程序提供了它有一台自己的私有机器的假象。
一个进程给一个程序提供了看似私有的内存系统、或者说\emph{地址空间(address space)}，其他进程不能读取或写入。
一个进程还为程序提供了看似独占的CPU来执行程序的指令。

xv6使用页表（由硬件实现）为每个进程提供私有的地址空间。
RISC-V的页表把一个\emph{虚拟地址(virtual address)}（RISC-V指令中操作的地址）翻译（或者说“映射”）到一个\emph{物理地址(physical address)}（处理器芯片送到主存的地址）。

xv6为每个进程维护了一个单独的页表，它定义了进程的地址空间。
如\autoref{f2-2}所示，一个地址空间包含了进程的\emph{用户内存(user memory)}，它从虚拟地址0处开始。
首先是指令，接是全局变量、然后是栈，最后是一个进程可以按需扩张的“堆”区域（用于malloc）。
有好几个限制进程地址空间最大值的因素：RISC-V的指针是64位的，当在页表中查找虚拟地址时硬件只使用低39位，xv6只用到了其中的38位。
因此，最大的地址是$2^{38} - 1$ = 0x3fffffffff，即\texttt{MAXVA}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h#L363}{(kernel/riscv.h:363)}。
在地址空间的顶部，xv6保留了一页用于\emph{trampoline}、一页用于映射进程的\emph{trapframe}。
xv6使用这两个页来过渡到内核并返回；trampoline页包含进入和离开内核的代码，映射进程的trapframe也是保存/恢复用户进程的状态所必需的，我们将在\autoref{ch04}中解释。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../imgs/f2-2.png}
    \caption{进程的虚拟地址空间的布局}
    \label{f2-2}
\end{figure}

xv6的内核为每个进程维护很多状态，都存储在一个\texttt{struct proc}里\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.h#L85}{(kernel/proc.h:85)}。
一个进程中最重要的内核状态是它的页表、内核栈和运行状态。
我们将使用记号\texttt{p->xxx}来引用\texttt{proc}结构体的元素，例如，\texttt{p->pagetable}是进程页表的一个指针。

每个进程都有一个执行线程（或者简称\emph{线程（thread）}）来执行进程的指令。
一个线程可以被挂起之后再恢复。
为了在进程间透明地切换，内核会挂起当前正在执行的线程然后恢复另一个进程的线程。
一个线程的很多状态（局部变量、函数调用的返回地址）都存储在线程的栈中。
每个进程都有两个栈：一个用户栈和一个内核栈（\texttt{p->kstack}）。
当进程在执行用户指令时，只会用到它的用户栈，它的内核栈是空的。
当进程进入内核时（因为一次系统调用或者中断），内核代码会在进程的内核栈上执行；然而当一个进程在内核中时，它的用户栈仍然包含保存的数据，但并不会被积极使用。
一个进程的线程在积极使用其用户栈和内核栈之间交替。
内核栈是独立的（并且被保护不受用户代码的影响）因此即使进程破坏了它的用户栈，内核也可以继续执行。

一个进程可以执行RISC-V的\texttt{ecall}指令进行系统调用。
这个指令会提升硬件的特权级别并修改程序计数器到一个内核定义的入口点。
入口点的代码会切换到内核栈并执行实现了该系统调用的内核指令。
当系统调用结束时，内核会通过\texttt{sret}指令切换到用户栈并返回用户空间，它还会降低硬件特权级别并恢复执行系统调用指令后的用户指令。
一个进程的线程可能因为等待I/O而在内核中“阻塞(block)”，并在I/O结束之后恢复。

\texttt{p->state}指示进程是已经被创建好准备运行，还是正在运行、还是等待I/O，还是正在退出。

\texttt{p->pagetable}以RISC-V硬件期望的格式存储进程的页表。
在用户空间执行一个进程时xv6会使分页硬件使用进程的\texttt{p->pagetable}。
一个进程的页表也记录了分配给该进程的物理页的地址，这些物理页用来存储进程的内存。

总的来说，进程结合了两个设计思路：地址空间为进程提供了独占内存的错觉，线程为进程提供了独占CPU的错觉。
在xv6中，进程由一个地址空间和一个线程组成。
在真实的操作系统中，一个进程可能有不止一个线程以充分利用多个CPU。

\section{代码：开始xv6，第一个进程和系统调用}
为了让xv6更加具体，我们将总结一下内核如何启动并运行第一个进程。
后续的章节会详细介绍这部分概览中展示的机制。

当RISC-V电脑启动时，它会初始化自己运行一个存储在ROM（只读内存）中的boot loader（引导加载程序）。

boot loader把xv6内核加载进内存。
然后，在机器模式下，CPU从\texttt{\_entry}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/entry.S#L7}{(kernel/entry.S:7)}开始执行xv6。
RISC-V刚启动时分页硬件是禁用的：此时虚拟地址直接映射到物理地址。

loader把xv6内核加载到内存的物理地址\texttt{0x80000000}处。
之所以把内核放在\texttt{0x80000000}而不是\texttt{0x0}是因为\texttt{0x0 : 0x80000000}地址范围内包含了I/O设备。

\texttt{\_entry}处的指令设置了一个栈，因此xv6可以运行C代码。
xv6为文件\texttt{start.c}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/start.c#L11}{(kernel/start.c:11)}中的初始栈\texttt{stack0}声明了空间。
\texttt{\_entry}处的代码把地址\texttt{stack0+4096}存入栈指针寄存器\texttt{sp}，这个地址是栈顶，因为RISC-V的栈是从高往低增长的。
既然内核已经有了栈，那么\texttt{\_entry}会调用\texttt{start}\href{https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/start.c#L21}{(kernel/start.c:21)}进入C代码。

函数\texttt{start}会进行一些只在机器模式下允许的配置，然后切换到管理模式。
为了进入管理模式，RISC-V提供了\texttt{mret}指令。
这个指令最常用于从一个从管理模式到机器模式的调用返回。
\texttt{start}并不是从这样一个调用返回，而是进行设置来伪装一个这样的调用：它在寄存器\texttt{mstatus}中把之前的特权模式设置为管理模式，通过把\texttt{main}的地址写入寄存器\texttt{mepc}来把返回地址设置为\texttt{main}，通过把\texttt{0}写入页表寄存器\texttt{satp}来禁用管理模式的虚拟地址翻译，并将所有中断和异常委托给管理模式。

在跳转到管理模式之前，\texttt{start}还执行了另一项任务：它编程时钟芯片以生成计时器中断。
在准备好这些后，\texttt{start}通过调用\texttt{mret}“返回”到管理模式。
这会导致程序计数器变为\texttt{main}\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/kernel/main.c#L11}{(kernel/main.c:11)}。

在\texttt{main}\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/kernel/main.c#L11}{(kernel/main.c:11)}初始化几个设备和子系统后，它通过调用\texttt{userinit}\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/kernel/proc.c#L233}{(kernel/proc.c:233)}创建第一个进程。
第一个进程会执行一个用RISC-V汇编所写的小程序，它会进行xv6中的第一个系统调用。
\texttt{initcode.S}\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/user/initcode.S#L3}{(user/initcode.S:3)}把\texttt{exec}系统调用\texttt{SYS\_EXEC}\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/kernel/syscall.h#L8}{(kernel/syscall.h:8)}的序号存入寄存器\texttt{a7}，然后执行\texttt{ecall}指令重新进入内核。

在\texttt{syscall}\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/kernel/syscall.c#L132}{(kernel/syscall.c:132)}函数中内核使用寄存器\texttt{a7}中存储的数字来调用期望的系统调用。
系统调用表\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/kernel/syscall.c#L107}{(kernel/syscall.c:107)}把\texttt{SYS\_EXEC}映射为\texttt{sys\_exec}，后者就是内核真正调用的函数。
正如我们在\autoref{ch01}中所说，\texttt{exec}会用一个新程序（这个例子中是\texttt{/init}）替换当前进程的内存和寄存器。

一旦内核完成了\texttt{exec}，它会返回到\texttt{/init}进程的用户空间。
\texttt{init}\href{https://github.com/mit-pdos/xv6-riscv/blob/risc/user/init.c#L15}{(user/init.c:15)}会按需创建一个新的控制台设备文件，然后把它打开为文件描述符0、1、2。
然后它会在控制台中启动一个shell。
此时系统已经就绪。

\section{安全模型}
你可能会想知道操作系统如何处理错误或恶意的代码。
应对恶意代码严格来说比处理意外错误更难，因此将这个话题和安全联系起来是有原因的。
这里给出一份操作系统设计中典型的安全假设和目标的高级视图。

操作系统必须假设一个进程的用户级别的代码将尽最大努力破坏内核或其他进程。
用户代码可能会尝试解引用一个超出它的地址空间之外的指针；它可能会尝试执行任何RISC-V指令，包括那些不适用于用户代码的指令；它可能会尝试读取和写入任何RISC-V控制寄存器；它可能会尝试直接访问设备硬件；它也可能向系统调用传递特定的值以尝试让内核陷入崩溃或做一些愚蠢的事。
内核的目标是限制每个用户进程，让它们只能读/写/执行自己的用户内存、使用32个通用RISC-V寄存器、通过系统调用允许的方式去影响内核和其他进程。
内核必须阻止其他任何行为。
这通常是内核设计中的绝对性需求。

而对内核自身的代码的期望则大不相同。
内核的代码被假定为由善意和细心的程序员编写。
内核代码被期望为没有bug，当然也没有恶意代码。
这个假设会影响到我们如何分析内核的代码。
例如，有很多内部的内核函数如果被错误使用可能会导致严重的问题（例如，自旋锁(spin lock)）。
当检查任何特定的内核代码时，我们希望能让自己相信它的行为是正确的。
然而，我们假设内核代码通常写得正确，并在使用内核自身的函数和数据结构时遵守相关的所有规则。
在硬件的层面，RISC-V CPU、RAM、磁盘等都被假设为符合文档的描述，没有硬件bug。

当然在真实世界中事情并不会如此直观。
想要阻止用户代码通过消耗内核保护的资源（磁盘空间、CPU时间、进程表槽位等）导致系统不可用（或崩溃）是很困难的。
编写没有bug的代码或设计没有bug的硬件通常是不可能的。
如果恶意用户代码的作者很清楚内核或硬件的bug，他们将会利用这些bug。
即使在全世界广泛使用的主流的内核（例如Linux）中，人们也在持续不断地发现bug[1]。
在内核中设计保护措施（断言、类型检查、栈保护页等）以防止它存在错误的可能性是值得的。
最后，用户代码和内核代码的分界线有时候是很模糊的：一些有特权的用户级进程可能提供基本的服务并高效地成为操作系统的一部分，而且在一些操作系统中，有特权的用户代码还可以把新的代码插入到内核中（和Linux的可加载内核模块一样）。

\section{真实世界}
大多数操作系统都采用了进程的概念，并且它们的进程大部分都和xv6的进程类似。
然而，现代操作系统，支持在一个进程有多个线程，以允许单个进程利用多个CPU。
在一个进程中支持多个线程，涉及到很多xv6中没有的机制，包括潜在的接口更改（例如，Linux的\texttt{clone}，它是\texttt{fork}的一个变体），来控制线程应该共享进程的哪些方面。

\section{练习}
\begin{enumerate}
    \item 向xv6添加一个返回可用内存数量的系统调用。
\end{enumerate}

